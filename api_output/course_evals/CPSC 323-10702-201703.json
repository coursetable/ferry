{
    "crn_code": "10702",
    "Evaluation_Questions": [
        "Your level of engagement with the course was:",
        "What is your overall assessment of this course?",
        "The course was well organized to facilitate student learning.",
        "I received clear feedback that improved my learning.",
        "Relative to other courses you have taken at Yale, the level of <u>intellectual challenge</u> of this course was:",
        "Relative to other courses you have taken at Yale, the <u>workload</u> of this course was:"
    ],
    "Evaluation_Data": [
        [
            0,
            4,
            5,
            19,
            42
        ],
        [
            4,
            8,
            18,
            20,
            22
        ],
        [
            7,
            7,
            11,
            30,
            17
        ],
        [
            10,
            15,
            19,
            16,
            12
        ],
        [
            0,
            0,
            9,
            25,
            37
        ],
        [
            0,
            0,
            2,
            10,
            60
        ]
    ],
    "Comments_Questions": [
        "What knowledge, skills, and insights did you develop by taking this course?",
        "What are the strengths and weaknesses of this course and how could it be improved?",
        "Would you recommend this course to another student? Please explain."
    ],
    "Comments_List": [
        [
            "\u00a0Understanding of Computer organization and further my programming skills. ",
            "\u00a0Although there were 5 programming assignments, completed in C, there was no constructive feedback provided after the assignments. This made it much more difficult to develop programming skills over the course of the semester.\r\n\r\nSome topics discussed in class--including virtual memory and RAID--provided greater knowledge, but the lectures themselves were so intensely theory-based that Google searches on the topics were what actually provided deeper insights. ",
            "\u00a0basics on how computers work, how the shell works, various linux system calls, tackling complex assignments and debugging them ",
            "\u00a0The underlying processes of a computer shell process, as well some computer organization. ",
            "\u00a0Coding linux utilities like find and Bash and a file compressor, how a computer works at a high level. ",
            "\u00a0I got a lot better at C programming, and learned a lot about the foundational stuff that makes C and UNIX and the like actually work.  I learned that computers are a miracle  the amount of stuff that's going on under the hood, from both a software and hardware perspective, is honestly insane, and I'm glad I know about it now because it's super cool. ",
            "\u00a0I learned a decent amount about computer architecture, the internet, encryption and decryption, and Bash. ",
            "\u00a0I learned about how to program in Linux and how computer systems work. I also learned about basic computer architecture and have a deeper understanding of how computers function at a lower-level. ",
            "\u00a0An understanding of the Linux kernel and the command line features of the OS (i.e. bash), a true exposure to the C programming language, debugging skills, a basic overview of the CPU and computer architecture, the principles behind compression and encoding of information, and so much more. ",
            "\u00a0I learned about systems programming and computer organization. I learned python. I learned how to better gdb my programs. ",
            "\u00a0The course covers computer architecture (storage, representation of information) as well as Linux and C. The course requires a great deal of coding in C. I did not gain a great deal of insight from this class. We studied computer architecture at a high level. The material is less about comprehension and more about memorization. ",
            "\u00a0my coding skills improved a lot and I learnt more about how computers work. ",
            "\u00a0I gained a better understanding of certain computer concepts like Unix/Linux operating systems and compression algorithms. ",
            "\u00a0Knowledge: 1\r\nSkills: 4\r\nInsights: 1 ",
            "\u00a0I really feel like I learned a lot taking this course, mostly concerning integer representations, compression techniques, basic elements of computer architecture, virtual memory, concurrency, and how to tackle large programming assignments. ",
            "\u00a0I learned various skills in computer science: how to create programs using C that interact with the Linux operating system, basic computer architecture, concurrency, hamming codes, and compression algorithms. Great overview of many interesting computer science topics. ",
            "\u00a0I learned more about computer organization and Linux/Bash, and how to interact with a system and file directory with C. ",
            "\u00a0I learned about some different methods of storing numbers and error correction, more about how a computer actually does things and allocates resources (processes, memory, pipeline), and a tiny bit about how the internet works. ",
            "\u00a0I learned a lot about unix and how computer's work (and how they evolved to how they are now). The assignments made me a much better programmer. ",
            "\u00a0C C C C C C C C C C and C ",
            "\u00a0We learned about system programming. That includes some high level computer architecture, file systems, memory management, compression,  processes. ",
            "\u00a0I learned about low-level computer operations: everything is a file and all files are bits, the filesystem, mutual exclusion, and so on. I also further practiced coding. ",
            "\u00a0Systems programming, programming time management, basic computer filesystems and architecture. Compression and Error correction, as well as memory hierarchy and caching. ",
            "\u00a0Understanding how the computer works on the system level. ",
            "\u00a0I learned the fundamental concepts behind the computer operating system, as well new ways to stretch my problem solving abilities as I implemented bash, piece by piece, throughout the semester. ",
            "\u00a0Learnt how to write system programs (from nfind to building a mini shell), and some theoretical concepts ranging from adders to compression, information theory and hamming codes to pipelining. ",
            "\u00a0About computer systems and writing long C programs. ",
            "\u00a0I learned a ton more about the specifics of bash, as well as the fundamentals behind lower level languages. ",
            "\u00a0great coding experience, and you learn a lot about computer architecture ",
            "\u00a0I gained a deeper understanding of systems programming and C because the course is structured to offer both simultaneously. The reality of this is that students spend the entirety of the course learning on their own and trying to consume the material of the class quickly before the exams. ",
            "\u00a0Computers. Systems. Memory. That stuff ",
            "\u00a0I learned a weird combination of topics, including error detection & correction, data compression, basics of parallelization, computer architecture, and systems vs user calls. Having an electrical engineering background was really helpful. It was sometimes strange to have such a hodge podge of topics. However, I learned a ton, and it was all useful. I really feel I have a much better grounding in computers and computer science in general. Another big skill I learned was improving my programming. I practiced structuring large programs, researching how to do things, and especially edgecasing/bomb-proofing my programs. ",
            "\u00a0I learned alot about how to write code for more complicated programs. I especially learned a lot of systems level programming such as how to interact with processes and how to access the filesystem. \r\n\r\nThis class also taught me a lot about computer architecture and computer organization. ",
            "\u00a0Error correction and detection, memory hierarchy, computer architecture, an indepth tour of C libraries really. ",
            "\u00a0I learned the importance of understanding the hardware-level of computers. Previously I thought it was irrelevant to software engineering, but Dana explained to me during office hours that an understanding of computer organization is part and parcel of almost any application. \r\n\r\nI also learned how to program better, because we had to write solutions out from scratch and the specs didn't give too much away. There was room for creative freedom and brainstorming good algorithms. ",
            "\u00a0Knowledge: Computer Arithmetic, Error Detection, Compression/Decompression, Computer Architecture, Concurrency\r\nSkills: Extensive C programming ",
            "\u00a0Knowledge: Computer organization (caching, ram, disk, instruction set architectures, concurrency / locking, networks) and fundamental systems (computer arithmetic, virtual memory, compression, error correction / detection). Notions of system space / user space, processes.\r\nSkills: Designing and building large systems from a specification. Planning, coding, debugging, testing. Creating algorithms and subroutines. Minimal collaboration on such projects. Very little hand-holding.\r\nInsights: Core computer architecture concepts such as caching, networks, arithmetic, error correction are related to how our own minds work. Questions of whether I want to spend a career doing this (perhaps in 223, but most in this course, do you get to dive into genuine software engineering). ",
            "\u00a0I learned to REALLY code. Also, some superficial information about networking, error correction, and computer architecture, although those topics are better covered in EENG 202 and 467. ",
            "\u00a0I learned a lot about how computers work, compression algorithms, bash, and so on. Everything on the syllabus basically. "
        ],
        [
            "\u00a0A very hard CS class. ",
            "\u00a0Lectures:  A professor who understands the material should be brought in to do the lectures, instead of Professor Angluin. Lectures need to be less theory-based in order to prepare students for careers in the technology sector.\r\n\r\nAssignments:  Programming specifications should be shorter and more organized in order to provide students with a deeper understanding of what is expected of them. Private tests should be done away with, as their extensive usage makes it impossible for students to know what they will actually be evaluated on.\r\n\r\nFeedback:  After each assignment, there should be the option to meet with the teaching team and discuss the code, including how it could be improved going forward.\r\n\r\nHelp:  A student forum should be implemented, as isolating students from one another makes it more difficult to make progress. Further, this method does not mirror the real world of the technology sector. ",
            "\u00a0More engaging lectures. ",
            "\u00a0I'm not sure I understand what is to be gained by doing these complex problem sets and essentially implementing a basic version of bash. It definitely gives one an appreciation for the complexity of these systems, but I don't know what the larger takeaway is. Additionally, the course material was interesting and important to know as a computer science major, but I feel like it was too surface-level, too survey-y. ",
            "\u00a0Lectures provided very little related to the psets. The psets often left you on your own to research the processes it was asking you to implement. I went to basically every office hours and needed the constant support to survive the class and actually build functional programs for the psets. ",
            "\u00a0Strengths: Problem sets were a lot of fun and taught me a lot. \r\nWeaknesses: Lectures were very dry. ",
            "\u00a0I had trouble paying attention in lecture and that came back to bite me on the tests.  The exams and the problem sets really aren't connected at all, which is somewhat unusual, at least in my experience.  You'll find quite a few '&' symbols in course titles at Yale, but 323 really does feel like two different classes.  So it's easy to be lulled into a false sense of security if you just do the psets and ignore the lectures, but that's not really an option for this course  the lectures are the best way to learn the exam material.  I wish they were a little more interesting but really that's just my fault for not taking them more seriously.  I found the problem sets very fun, though they're a ton of work, and my friends in the class did not feel the same way about them.  But I think the level of work is appropriate and I learned a lot! ",
            "\u00a0323 is a lot to swallow. It's valuable because it teaches the student a significant amount of material from computer architecture to Linux to C to compression and beyond. While the amount of material covered is immense, it somehow doesn't feel like it's trying to \"do too much in too little time,\" rather, it demands that the student make *more* time to accommodate the requirements of the course. More importantly, it teaches the student to be disciplined and to complete rigorous and complex projects in the form of the homework assignments. While they aren't easy or simple, by investing high-quality time in them, the student learns that they can succeed, and thus learns to work with high-quality on their assignments. \r\n\r\nPerhaps one weakness is the archaic-ness of the classroom environment. While some of the material is posted online in the form of hand-outs, much of what is done is relegated to the chalkboard (which is erased after each class). I recognize that a lack of initiative in pursuing lingering questions is partly the burden of the student, this class just seemed less organized (in terms of resources--digital or otherwise) than other courses (especially in the CS department). \r\n\r\nAdditionally, the re-grading policy (or lack thereof) should be re-examined. While I understand the importance of using private test cases to prevent cheating and to encourage \"edge case testing\" as a part of the assignment, the lack of transparency can be very frustrating (especially when one discovers a simple bug that lost them several points). Additionally, giving students the opportunity to rework their solutions and learn from their mistakes is an invaluable part of the learning process which is passively discouraged by not offering any benefit to doing so. ",
            "\u00a0Strengths: If you are a computer science major with significant programming experience and an interest in systems, this is a critical course that outlines the foundation of computer architecture and challenges your programming prowess. Many computer science majors and nonmajors are not people with significant programming experience and an interest in systems.\r\nWeaknesses: The course does not fit nicely into the core computer science curriculum. This course is meant to be taken after CPSC 223, which is meant to be taken after CPSC 201. It is completely feasible for a student to arrive at Yale with no coding experience, to follow the curriculum, and to take 323 without experience with difficult programming. The leap from 223 to 323 is too large. Several people dropped the major because the curriculum did not prepare them for 323. This class is unabashedly a weed-out class, and it should not be this way. ",
            "\u00a0Good amount of work, and one learns a lot in completing it. Not sure how the class could be improved - I think it seems to have achieved most of what I expected out of it. ",
            "\u00a0Strengths: 10\r\nWeaknesses: 2 ",
            "\u00a0This course really benefits from its long history - it's VERY well organized. For me, this is one of the most important elements of the class and is what prevented me from drowning in the generally difficult material. Lectures were pretty straight forward. While I enjoyed the course and felt like I had a pretty good general understanding of what was going on, I found it really difficult to perform well on exams no matter how much preparation I did, especially since this material was all brand new to me. ",
            "\u00a0Taking 323 feels like you're taking two separate courses. The problem sets and lectures are (almost) completely unrelated, which can be disconcerting - especially when midterms come around and all of the time you spent on the course was on the problem sets and none of the lecture material. The problem sets do help you understand things conceptually to some extent, but there's such a wide disconnect between what you do in class and out of class that makes everything feel rather unrelated. Additionally, the problem sets are judged primarily on the private cases, which are often obscure edge cases that, while intended to make you think more specifically about the problem, are rather pedantic. Because of this, it feels like people who work in groups or know ULAs personally have an advantage as they share things like potential edge cases with one another. In the end, I've come out of the course feeling like a better programmer and do think I better understand how computers work, but am also tired. ",
            "\u00a0This class teaches a lot of material in a short amount of time and forces students to learn how to really program and debug code. I was a little disappointed that the class and the problem sets were very different: very little that we learned in class we were able to actually program and implement on our own. ",
            "\u00a0The psets were grade, the lectures and tests not so much. ",
            "\u00a0The course is overall very good and bettered my coding. I do feel, however, that some of the lectures lacked contextualization and dove straight into the material, which made it all harder to synthesize. ",
            "\u00a0The course is well-organized  problem set specifications include a lot of details  and the TAs and professor are very helpful. The topics felt a bit sporadic, and it seems like it would make more sense to align class topics with homework topics  there was often a delay of 1-2 weeks. Also, both the problem set specifications and lectures could have benefitted from a broader, opening description of what the content is and how it relates to the other course topics  sometimes it was hard to get a broader sense of how the different topics were related (or distinct), why they were important to study, etc. Personally, I also would have liked to spend more time (or have a pset on) compression and error-correcting codes. Finally, I think it could really be improved by having a very small incentive to go back and fix the test cases you failed (maybe 10% of points back?) ",
            "\u00a0The psets are all beautifully crafted. Completing them always felt like an accomplishment. Dana is a great professor. I think she filled in for Stan as well as any professor could have hoped to have done. Overall the class felt very worthwhile. I think this would true for anyone with an interest in Computer Science and whos ready for a semester of good, hard work. ",
            "\u00a0Strengths: I learned a huge amount.\r\n\r\nWeaknesses: Workload. The assignments are very time consuming (rewarding but time consuming). As a result, from what I gathered, almost no one did the readings. The readings were often redundant with what we learned in class, and would have taken many additional hours each week to read. To encourage people to do the readings, I would suggest either cutting them down to only what is not covered in class (and marking the rest as \"recommended\" or \"supplementary\", or just acknowledging that they are recommended so that people don't feel as overwhelmed with the course (it's overwhelming with just the assignments). ",
            "\u00a0Strengths: the lectures (in the course's 37th edition) are very organized and tightened. They tell students exactly what the students need to know. The homeworks, however, seem somewhat disconnectedI do not know what lessons I should be learning from the homeworks (other than practicing my coding). ",
            "\u00a0Strengths: extremely intellectually challenging and stimulating, forces you to seriously level up your programming skill.\r\nWeaknesses: soporific lectures and unnecessarily difficult first exam ",
            "\u00a0The rules on collaboration are extremely strict and seem to create an unfair balance in the course.  A large amount of people in the class choose not to follow the academic honesty policy by working together on problem sets to find the solutions, and as a result, those who chose to work honestly spend more time to get those same results.  It seems like the rules should either be more enforceable or more conducive to productive collaborations. ",
            "\u00a0This course is definitely rigourous, and it leaves you with a knowledge of how to write better code. However, personally, it was quite frustrating that the lectures and the coursework were barely related. It felt like I was taking two different classes, almost. Having homework that is related to the coursework helps to reinforce the concepts. ",
            "\u00a0Strength: Very, very, very good lectures. Amazing problem sets.\r\nWeakness: Homework has almost nothing to do with the lectures. :< ",
            "\u00a0This is a required course for the major, known as the hardest course one can take. This hype and stigma really stifled me at the beginning of the semester, and I believe most students were extremely intimidated to just walk into class. However, the course has excellent support in the form kick-butt TAs who are available a ridiculous amount of hours who really made this course doable (almost). This course could bee improved by somehow making all the electives not have hw due at the same time, or at least always a day or two after. I dropped my electives in order to put the effort I needed to into this course. ",
            "\u00a0Very interesting material and great teaching. Assignments were long and challenging, but a lot of fun. ",
            "\u00a0The psets and course content cover very different areas which makes the course needlessly difficult. ",
            "\u00a0One large weakness is I felt the lectures had very little to do with the psets. ",
            "\u00a0This course should be two parts, or modified in expectation. Each part on its own is very well thought out--it's just too much for one semester. ",
            "\u00a0You learn a lot about intricate details of computer hardware and operating systems.\r\n\r\nThis class is a lot of work. Don't take it unless you are a CS major. ",
            "\u00a0The strengths are the topics and the programming assignments. One thing that could be improved is that the book is overcomplicated and occasionally conflicting with what's said in class, so having some extra way to review what happened in lecture would be nice. ",
            "\u00a0The strengths of this course is very good problem sets. The problem sets are very difficult and time consuming, but you learn a lot by doing them.\r\n\r\nA weakness may be the disjointness of the lecture and the problem sets. The vast majority of the time, the material in lecture and on the problem sets were completely unrelated. This is just how the course is, as it is difficult to lecture on material that you will be coding. The exams in this class are largely spent on material just covered in lecture. In some ways, the course could be considered two courses: the problem sets and the lectures/exams. ",
            "\u00a0The assignments and the lectures are pretty much orthogonal which can be both a strength and a weakness. Reports of the psets' difficulty are greatly exaggerated -- just start early and manage your time properly.\r\n\r\nYou will have to learn a lot on your own (many important details about library functions, idioms, etc) are not taught in class; learning to close read man pages will be life-saving. Exams are fair and stick closely to what is taught in class.\r\n\r\nDana is a great lecturer, but it's unfortunate that her class was always after lunch because food comas are a thing. I also kind of wish that I could have taken the class with Stan himself -- get well soon! ",
            "\u00a0The PSETs were challenging and made us think about the right data structures and algorithms to use. However, Parse was particularly difficult because it assumed knowledge of syntax, and it look unusually long to understand the specs.\r\n\r\nThe course material covered in lectures was separate from the homework, which means that we did not get a chance to practice concepts taught in lecture, or receive feedback about our progress in understanding the lectures. The only feedback came during the midterm and the final. This is unfair. \r\n\r\nWhat the practice midterm asked of us was completely different from the actual midterm. I was caught off-guard and I wish I had a better sense of what was expected of me in my preparation. ",
            "\u00a0Strengths: Substantial material was taught.\r\nWeaknesses: \r\n-Important information that was essential to the assignment, such as packing C structs, bit fields, using gprof etc were NEVER explicitly taught. Where resources were to learn these things was also NEVER explicitly pointed to. \r\n-Lack of personal feedback on code means that it's very hard to improve. You might as well be throwing your assignment into a black hole. \r\n-Assignments were never returned promptly, and by the time they were returned you had already submitted the next assignment so you had no chance to learn from your mistakes in the previous assignment ",
            "\u00a0The class gives a good understanding of computer architecture and UNIX systems. The only weakness I can think of is that the material tested in midterms and the material on p-sets can often not have much in common ",
            "\u00a0Hardest part about this class is that your in-class lecture don't (in any significant way that will help you) align with the homework assignments. To do the homework, it takes copious amounts of reading and research. However, you still have to come to class because that's where you learn what you'll need for the midterms. In this sense, it's really: Systems Programming for homework, Computer Organization in class for midterms. What makes this class so difficult is that the homeworks take forever, but I don't see how this could be fixed as the computer organization is so important, dedicating any class time to the material in the homework would talk away from what has historically been done in class. Further, there is precedent that people have been able to do the homeworks on their own accord without such a change. ",
            "\u00a0Strengths: Clear, productive lecture. Exceptionally well-designed problem sets.\r\nWeaknesses: Damn hard. However / as a result, the TAs seemed to give hints that sapped the essential difficulties from the problem sets. After psets were over, having an incentive / clear way to see what you got wrong + why would have facilitated learning. Lecture sometimes could have been more theoretical / algorithmic and less \"man-page\" / \"taxonomy of ...\" ",
            "\u00a0The problem sets are well designed and well-specified. I appreciate the extensive help hours. On busy nights, though, we need *even more* ULAs! (and on quiet nights, the ULAs are sitting idle). Using the data collected this semester, you could redistribute the ULAs so that their resources are better allocated to match demand. ",
            "\u00a0Strength is that there are TAs most days of the week at convenient hours to help you out. Weakness is that there is a lot of material that most of the time we do not get to finish what was planned for the day. ",
            "\u00a0The lecture is not related at all to the homework assignments. There are few TFs for hundreds of students. There is very little help offered to students that are struggling. "
        ],
        [
            "\u00a0Yes! Take it if you are willing to face the challenge. ",
            "\u00a0No, unless a student is required to take this course for his/her major, this course should not be taken. The class is too disorganized to facilitate learning. \r\n\r\nThe programming assignments are accompanied by program specifications that are long and disorganized, making it difficult to determine where to begin for an assignment. Further, each assignment has approximately 15 public tests that can be used to assess the performance of one's program. However, there are also around 45 private tests that the student can't access. These tests often assess functionalities that were not clearly required of the program.\r\n\r\nWith the lack of instructor help and unclear instructions on assignments, this class does not prepare students for real jobs in the technology sector, where the requirements are clearly laid-out and there is a support team available. ",
            "\u00a0The problem sets are definitely manageable. Lectures were not very engaging. ",
            "\u00a0Probably only for CS majors. You don't need to do this to yourself if it's not required - you won't get very many practical skills out of this class that you can't get elsewhere. ",
            "\u00a0323 is a grind. The things we learn aren't that complicated, but because no one explains it to you, you have to flail around and try to figure it out searching online. Office hours were key to survival. ",
            "\u00a0The class is time consuming, and if you're looking at this review you probably have to take it anyway.  Just start the psets early and go to office hours, and you'll be fine.  Maybe do 4 credits though. ",
            "\u00a0Yes, if you want to understand the linux system very well and get practice in systems programming. ",
            "\u00a0If you're a CS major, yes (duh). You have to take it. Whether you enjoy it or not isn't really the essential question.  I liked it, some didn't.\r\n\r\nIf you're not a CS major, don't take this class, it's literally all pure, hard CS.  If you aren't a CS major but you like computers and computer science enough to slog through the incredible workload of 323 then honestly just switch majors. ",
            "\u00a0I would recommend this class, but not sure if Angluin is the best professor for the class. She is a very quiet lecturer, but lectures at a good pace and usually does a good job of explaining. At times it was difficult to stay awake in class. The psets take a lot of time, but I felt like I learned more and more after each one. ",
            "\u00a0I don't think many non-CS majors willingly take 323, so the following is more an impression of the class rather than any sort of recommendation. \r\n\r\nThis class is tough, but not in a way that a high-level math or physics class is tough. The concepts presented in class don't require an extraordinary level of genius to comprehend, but the real difficulty lies in a) incorporating them and b) putting in the work. If you can successfully accomplish these things, you'll learn a lot about computers and even more about C.\r\n\r\nThis class is \"schizophrenic.\" The lectures cover material that is related to the concepts used on the assignments, but for the most part, they are two separate beasts. In a sense, this class is almost like two classes in one. Be prepared for this, but know that the classroom portion of the course is on par with other Yale courses in terms of difficulty and rigor.\r\n\r\nOn the assignments side, this class will demand a *lot* of your time. It can be a part-time job depending on how long an assignment takes you. Sometimes the solution comes more quickly and sometimes it takes hours of trying to dissect the same, infuriating bug, but with enough work (and help from the teaching staff), it's definitely not impossible. \r\n\r\nThat's the thing about 323. While you don't have to be the sharpest tool in the shed to do well, you have to be willing to devote a lot of time (and specifically, non-distracted, truly focused time) to the homeworks.\r\n\r\nI would definitely recommend this course to another student. Firstly, it teaches you to find ways to partition your time so that you have large blocks of conducting intense, focused work, which I think is an incredibly valuable skill in a world where distractions are the norm and true focus is hard to find. Secondly, 323 completely breaks down the \"magic box\" that is the computer. By learning how the CPU works, it becomes so much more understandable (which is really cool!). Finally, you'll gain some invaluable C experience. Regardless of what you go on to do, if it's at all related to coding, you'll appreciate the underlying workings of high-level code by really understanding C. You'll also sharpen your debugging skills, which is really important for your career/future coursework. ",
            "\u00a0You have to take this if you want to be the very best, like no one ever was. Angluin was hard to hear in class sometimes and made you want to sleep in class. Besides that, a pretty good experience, I feel more confident about my CS abilities but I wouldn't do good without a curve, so I hope there is one. It was clear what would be on the midterm and final, just know the lecture material really well because there are a couple questions where you'll have to actually *gasps* think critically. P-set 1 was the hardest one to me actually, the rest weren't as bad. But I hear the assignments rotate every few years and we got unlucky with a hard first assignment. ",
            "\u00a0I would recommend this course to another student if and only if they wanted to be a computer science major. Even then, I wouldnt recommend this course if there were another course a student could take to fulfill their systems requirement. ",
            "\u00a0Good course. If you have a solid CS background not as bad as it is made out to be. PSets took 10-20 hours over two weeks, which honestly isn't that horrible of a workload (especially since they were semi spaced out). Lecture isn't incredibly useful, seems like often psets and class cover entirely different things (which I think is the intention however). \r\n\r\nJust a midterm and a final otherwise, which are relatively straightforward and just require you to memorize certain things. Not much computation or actual work to be done in the tests (such as with 223 or 201). Going to lecture and taking notes will make tests very straightforward, if you dont or dont take notes, then you'll have to scramble last minute, but still not difficult to read through the books and look over other notes to do well on the tests. \r\n\r\nIf you don't have a good CS background class might be a struggle, but if you feel you are a strong programmer, don't stress. Definitely learned a lot from the class and doing the psets, so overall a quality class. ",
            "\u00a0Not quite what it's hyped up to be - sure, there's quite a bit of content and assignments take a while to finish, but there were only 5 (should have been 6) assignments over the course of the semester so it's alright if you manage your time well. At no point did I feel like I was out of my depth in this class. Nonetheless it was still a great learning experience, and I would recommend this class to anyone who would like to know more about systems and systems programming. ",
            "\u00a0Come on, if you want to take this course you're probably already thinking about it, regardless of what I say. Nonetheless, there's a *little* detail to consider, something they don't tell you in the orientations, and that is: this course has an absolute Beast hiding inside it. In fact, the entire course is structured around containing and avoiding the beast, much as the Labyrinth was constructed to contain the Minotaur... I'm not going to *tell* you what this is - that would be against the Seventy-Seventh Code of Conduct of the Code, but what I can tell you is that you ought to be prepared, in case the worst comes, for walls of text the likes of which you have not seen before. ",
            "\u00a0CS majors don't have a choice, and I would only recommend this class to someone who is willing to put in the insane amount of time that is necessary for the problem sets. If you are willing, then this is a great class that teaches you a lot. ",
            "\u00a0Take it if you need it for the major. Otherwise, take it Credit/D. ",
            "\u00a0Only if 1. You are very, very interested in Systems Programming, or 2. You are a computer science major. ",
            "\u00a0Overall the course was useful in that I learned a lot. However, it was all self-learning from doing the psets. The lectures themselves were useless and poorly organized and taught. Compared to other similar classes at other universities, I feel like this course (in terms of the actual teaching) was VERY lacking. ",
            "\u00a0I would not recommend taking this course if not a CS major. Personally I found the material a bit dry and the Psets a brain drain, but nonetheless a comprehensive course that really requires you to rethink how you code. ",
            "\u00a0I would cautiously recommend this course to another student, but warn them (A) to take it seriously (4 hard classes alongside this one is not a good call), and (B) to understand that its going to be a lot of random topics, rather than an extremely coherent whole. The problem sets are probably manageable if you start them ahead of time (which I didnt), which made it a very stressful addition to my schedule. But its well-run and the content is relatively interesting. ",
            "\u00a0Yes!  If you are committed to this class you will get a lot out of it. That being said, the C psets (there are four of them) will literally take 25-40 hours each in order to complete. And you know thats true because you will log every single one of those hours (hypothetically speaking) just like you did for 223. In other words: plan your semester accordingly and youll be fine. All in all I thought this class was actually very manageable. ",
            "\u00a0If you take this, dedicate your semester to it (take fewer other credits / guts) and plan ahead on assignments. Know that it will consume your life. Know that you will learn a lot and come out a better programmer. Know that it is required for the CS major :). ",
            "\u00a0Yeah totally. ",
            "\u00a0CPSC 323 really does meet the hype. Our class was lucky that we only had to do 5 psets instead of 6 which made the class much  more manageable. Dana is probably the best professor in the CS department, so we were lucky to have her. I enjoyed the class, and my recommendation is to go into office hours to do well on the problem sets. This class is like two classes: the class material and the psets, both are very time consuming.  So make sure to keep that in mind and always go to class to keep up with the material! Also, I was probably averaging 45 hours on the psets, but I know people who were much faster. I would definitely reccommend coming up with a plan of action and understanding almost all of the problem set before coding.  On LZW, make sure you pass all the public test cases before submitting, because if you pass all the public ones you will likely pass all the private ones. Best of luck to you! ",
            "\u00a0If you're interested in the level where hardware meets software, this class is for you. If you're an EECS major, consider also taking EE467 which covers many of the same concepts but from the hardware perspective. This class does not dip into hardware at all but has brushes where knowledge of hardware improves your understanding. ",
            "\u00a0Context: This class was NOT required for my major. I took it as my main course for the semester, and took a relatively light course load otherwise.\r\n\r\nFirst and foremost, this class will be your main class if you take it. There is no avoiding putting work for this class at the top of your to-do list for the entire semester. BUT, the programming skills the class forces you to develop are extremely valuable, and that ultimately makes this class highly recommendable.\r\nAll of the other evaluations you are reading are probably freaking you out. YOU'LL GET THROUGH IT. It's an amazing class.\r\n\r\nYeah, it's hard. But manage your time well and structure a light course load around it and you'll be fine.\r\n\r\nGo to office hours every day. Bring headphones and work on your own, but speed up your programming process by asking TA's to help you solve bugs that you've been stuck on instead of trying to debug for hours.\r\n\r\nFinally, if you're going to be the person who goes to office hours and asks the TA's to basically tell you how to do the problem sets (different from discussing your planned solutions), don't take the class. If you're not willing to put in work and manage your time, how do you expect to be able to do so at a real software job outside of college? ",
            "\u00a0YES YES YES ESPECIALLY IF DANA IS TEACHING IT AGAIN. You know that \"wooooaaahh\" (or \"WOOOOAHHH!\") feeling when you finally understand something? I got that so many times in the lectures. And the problem sets are so cool! Yes, they are challenging, but once you've finished them you will feel the joy of having become a slightly better programmer. ",
            "\u00a0I mean do you have a choice? If you're set on doing CS then it's just something you have to go through. I actually thought the first half of the course was worse because I didn't know what to expect. The second half had more interesting assignments and I found the work strategy that worked best for me and also the deadline to drop the class had passed so my ducks were gone. I don't understand why the course is organized the way it is, like after doing so much theoretical CS we're meant to be able to do these assignments from scratch and figure out test cases, random C libraries, algorithms from scratch, etc. The ULA's are mostly nice and helpful but there are just too many students for them to be effective. Anyway, you'll survive but it's not a fun time. If I talk to students after we submit an  assignment and they all feel physically ill then there's probably something wrong with this class. ",
            "\u00a0I would only recommend this course to someone who is absolutely sure that they are a computer science major. If not, even though the in class material is interesting and possibly useful for EE or even management of software development, the workload of the problem sets is not worth. If you are not a CS major, just audit the class. ",
            "\u00a0Yes. It is a great course with very interesting material. Homework assignments are long and hard but doable and fun. Professor Dana is a great teacher. ",
            "\u00a0It's very hard, so not unless they uad to take it for their major. ",
            "\u00a0This is a must take if you plan on pursuing studies in computer science. ",
            "\u00a0If you're taking this course, it's because you're going to be a CS major, so whether or not students recommend this course to you is irrelevant. Some advice would be to work very hard early on to make sure that you get the points on the earlier homeworks. Do not fall victim to the late policy, and remember that most of the class is based on private cases. Be sure to keep up with the class material, as it will come back to haunt you days before the exam. ",
            "\u00a0Only if you are CS major and have to take it lol. Otherwise don't do it to yourself ",
            "\u00a0Ah, the famous 323. I can't believe I'm saying this, but I am SO glad I took this class. I would take it again, and again. I actually had fun! You know how I had fun? I started the programming assignments on Saturday after the previous one had been due, and I took a chiller courseload. And I did spend 30-odd hours on each assignment, but spread out over 2 weeks. So yes, this class is kind of crazy in the workload, but honestly I think the hype is more intimidating than the actual assignments. Go to office hours early to get the help you need. The spec is deliberately obtuse about things, you have to figure them out and the only way to do that is to put in the time to think, work, and run into those issues, and then have a few days left to brainstorm edge cases. Work with people! The ULAs are incredibly helpful also. The downside is having to switch gears for the exams, which don't overlap a lot with the programming assignments. Even if they overlap in topic, the exams are just so differently formatted. Dana is wonderful! Take it, and do not fear! Just ask for help, find friends, and don't get overwhelmed. Here's the truth: LZW is the hardest to debug, Bash is the hardest to edge case. You can do it! ",
            "\u00a0I would definitely recommend this class to another student!! You learn so much in this class, and it really gives you a great sense of accomplishment. It is just important to realize that this class will take up a lot of time (probably at least 20 hours per problem set). You need to plan your semester accordingly; in addition, it is really important to work on the problem sets a little bit each night during the two weeks that you have. You will have a much better experience if you work on the problem set incrementally as compared to trying to cram it all into a couple days. ",
            "\u00a0If you're a CS major, this is supposed to be your trial by fire. You come out a better C programmer. It might be rough but you learn a lot. ",
            "\u00a0If you're a major, you'll have to take it. The only question is when. \r\n\r\nIf you're a sophomore deciding whether to take this now or in your junior year, I would recommend now, because the department's best courses like OS and Networks require 323 as a prereq, and you would want to be able to take these courses over your junior and senior year, instead of just within one senior year. \r\n\r\nYou will become a better programmer and deal with interesting concepts like processes, and algorithms in compression. I start seeing these concepts everywhere, in the side project I work on or my student job. \r\n\r\nIf you have been a diehard high-level software kind of person, this course will make you realize the importance of low-level software and hardware details, in terms of optimizing speed and preventing concurrency problems. Besides that, you can also buy computers using nerd jargon, like \"what's the RAM size. what's the cache size.\" ",
            "\u00a0If you're a CS major, you have no choice but to take this course. If you're still considering CS, this would probably be the course that decides whether you want to continue CS for you. ",
            "\u00a0You gotta take it. Sit down, code, grind it out. And if there's anything I can emphasize enough for those of you skimming this review right now: PLAN BEFORE YOU CODE! It will save you hours. And I mean hours. ",
            "\u00a0Essential knowledge for systems programming / software engineering. like it or not, you will do serious soul-searching about whether this lifestyle is for you. very hard, but graded (as in your term grade) pretty easy. ",
            "\u00a0For the handful of brave souls from outside the CS or EECS majors who are considering taking 323 just for fun, be aware that it will be your significant other for the semester. You must build a faithful, loving relationship with 323. You must take it to dinner on weeknights, dedicate quality time to it on the weekends, and spend intimate nights alone with it. You must text-edit it every day so it doesn't get lonely. When the two of you have a falling-out and you slam your laptop closed in frustration, you must fall asleep thinking about it, so that an answer might appear in your dreams to make everything right in the morning. You must make sacrifices--many a time will come when you want to hit up Woads, but 323 will be tired and won't feel like going out, so you will sigh and stay in to tend to its leaky memory and massage its fragile edge cases. But if you can't handle 323 at its worst, you don't deserve it at its best. Stay true to 323 and you will emerge a better coder. Plus, you can just bail after 3 months! ",
            "\u00a0If you are interested in CS and have taken 223, challenge yourself and take this course! You won't feel you are fully committed to CS until you take this course. ",
            "\u00a0Don't take this class if you don't have to. "
        ]
    ]
}