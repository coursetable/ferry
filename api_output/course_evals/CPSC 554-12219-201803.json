{
    "crn_code": "12219",
    "Evaluation_Questions": [
        "Your level of engagement with the course was",
        "What is your overall assessment of this course",
        "The course was well organized to facilitate student learning",
        "I received clear feedback that improved my learning",
        "Relative to other courses you have taken at Yale, the level of <u>intellectual challenge</u> of this course was",
        "Relative to other courses you have taken at Yale, the <u>workload</u> of this course was"
    ],
    "Evaluation_Data": [
        [
            0,
            0,
            0,
            0,
            3
        ],
        [
            0,
            0,
            0,
            1,
            2
        ],
        [
            0,
            0,
            0,
            2,
            1
        ],
        [
            0,
            0,
            0,
            1,
            2
        ],
        [
            0,
            0,
            2,
            1,
            0
        ],
        [
            0,
            1,
            1,
            0,
            1
        ]
    ],
    "Comments_Questions": [
        "What knowledge, skills, and insights did you develop by taking this course",
        "What are the strengths and weaknesses of this course and how could it be improved",
        "Would you recommend this course to another student? Please explain"
    ],
    "Comments_List": [
        [
            "\u00a0A well-rounded introduction into software verification. I now feel I have an appreciation of the vast scope of the topic and individuality of approaches and solutions for specific instances, yet also a solid foundation in the general structure that those solutions must take. As such, I think given the task of working with verification in research or industry I would understand the nomenclature and core idea, which is about all that can be asked for outside simple generic instances. For those generic instances (like say, decision procedures for basic constructions or Hoare logic) I feel I have a strong understanding of how the algorithms and procedures presented in the class work, even if why they work is left more to intuition. ",
            "\u00a0a solid foundation in the field of program verification ",
            "\u00a0I learned an entire field of computer science exists. I learned Hoare triples, verification conditions, first-order logic, guarded commands, weakest preconditions, strongest postconditions, foundations of SMT, separation logic, model checking algorithms, SAT solvers, the DPLL algorithm, and CDCL solvers, and abstract interpretations of programs, plus some other stuff I'm forgetting. I know enough to learn how to formally verify programs that I need to verify. "
        ],
        [
            "\u00a0Strengths: Good lectures, moved at a perfect pace to cover a wide-variety of material while never feeling like pertinent details would left out. Projects were instructive, interesting, and well-balanced between difficulty and feasibility. Slides were very detailed and helpful for homeworks and projects, which is important because of the lack of textbook and intricate details of many of the logics, procedures, and algorithms used.\r\n\r\nWeaknesses: Homework assignments felt rote and not particularly useful, hence the \"agree\" on (5). Course lies at a strange point between theory and practice, and would probably improve from a solid step in one of those directions. Either more towards theory with more proofs and discussion of why techniques work, or towards application with more emphasis on actual coding projects and less on toy examples executed by hand. Three hour, handwritten exam felt particularly unsuited for the course, with nothing on it requiring any thinking beyond direct application of known techniques. A major coding project seems preferable. ",
            "\u00a0The slides are really well-organized. The guest lectures are really interesting. ",
            "\u00a0Strengths: This is a detailed introduction to the field of formal methods. The two course projects helped solidify learning of lecture material. I feel I at least know how to start tackling most problems in the formal methods field, although I'd need to read quite a bit more to be good.\r\n\r\nCons: Problem sets were long and tedious. It wasn't always clear how the questions helped us learn the material. Sometimes it felt unnecessary to go through the exercise of writing out a solution as a computer would solve a problem: we'd just get the computer to solve the problem. Writing out the solution by hand really only helps if we plan to write our own implementation of these algorithms. It may have been sufficient to simply state what we would do, rather than write out every operation in detail. "
        ],
        [
            "\u00a0Yes, I think it's a very useful introduction into an important systems field, and enjoyable enough on its own for a theory or applications person looking to stretch their legs a bit. ",
            "\u00a0Yes! This course is a very good introduction to programming languages research. ",
            "\u00a0I would recommend this course to someone who wanted to study formal methods. I think it's too detailed for anyone outside of the field looking to just use a couple of the techniques. I think you have to really want to push through the large workload. "
        ]
    ]
}