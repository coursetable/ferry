{
    "crn_code": "10687",
    "Evaluation_Questions": [
        "Your level of engagement with the course was:",
        "What is your overall assessment of this course?",
        "The course was well organized to facilitate student learning.",
        "I received clear feedback that improved my learning.",
        "Relative to other courses you have taken at Yale, the level of <u>intellectual challenge</u> of this course was:",
        "Relative to other courses you have taken at Yale, the <u>workload</u> of this course was:"
    ],
    "Evaluation_Data": [
        [
            0,
            3,
            13,
            27,
            76
        ],
        [
            5,
            11,
            31,
            44,
            29
        ],
        [
            3,
            12,
            20,
            58,
            27
        ],
        [
            5,
            23,
            35,
            36,
            20
        ],
        [
            0,
            1,
            10,
            35,
            74
        ],
        [
            0,
            1,
            5,
            15,
            98
        ]
    ],
    "Comments_Questions": [
        "What knowledge, skills, and insights did you develop by taking this course?",
        "What are the strengths and weaknesses of this course and how could it be improved?",
        "Would you recommend this course to another student? Please explain."
    ],
    "Comments_List": [
        [
            "\u00a0The systemsy stuff learned in class was more of an overview: number representation, caches/virtual mem, concurrency, pipelining etc. But the programming assignments were far more instructive - as I learned by doing. I became more confident in my C programming abilities, and gained knowledge of lesser known system calls and UNIX. ",
            "\u00a0in depth understanding of how computers really work, starting with methods of addition with logic gates, and working through all of concurrency/processes, computer instructions, and memory/caching ",
            "\u00a0Basics of computer architecture and organization, including the number representations, error detection and correction, memory architecture, data compression, parallel processes, and virtual memory near the end. ",
            "\u00a0Great course. Learned everything about systems programming and computer organization. ",
            "\u00a0Systems programming, shell, unix, c, computer architecture (Paging, Segmentation, bit) ",
            "\u00a0Understanding of Linux System I/O, Error Checking, Memory Hierarchy, CPU functionality, Data Compression, Shell functionality ",
            "\u00a0A general understanding of computer systems and how they function. I also gained better programming practices and realized the expanse of computer science, but also the ugly nitty gritty parts of cs. ",
            "\u00a0I learned to code in a more organized manner. ",
            "\u00a0I learned an incredible amount by taking this course. I learned how to be a better programmer, how to survive on less sleep, how the inside of a computer works, and how to tell what kinds of chalk are best. But seriously, CS323 forces you to program a ton so you come out the other side as a better programmer. I learned basically everything I now know about how systems programming works and what it means to spend so much time on a problem set that it becomes you. I learned quickly how to edge case my programs, which is an incredibly important skill for computer scientists to have. In a way, I think this is the most valuable skill in the class. ",
            "\u00a0I learned a lot about systems programming, concurrency, ISA, compression, error detection & correction, and various other concepts ",
            "\u00a0The problem sets deffinitely helped me improve my programming skills. The class material was also very interesting, I learned a lot about computer architecture and it was cool to learn about hardware. ",
            "\u00a0How to better code in C, more about bash, how my code connects to the system level, how to code using a bottom-up method rather than a top-down method, how to persevere and struggle like I've never struggled before ",
            "\u00a0I learned about computer architecture, systems programming, data compression, virtual memory and much more. ",
            "\u00a0This class taught me to become a much better C programmer, and since a lot of the homework material diverged from class concepts, it also helped me navigate online resources to better understand the task at hand. ",
            "\u00a0I learned about how shells work, and further important basics about how a computer functions. ",
            "\u00a0In 323, you get to learn a lot of aspects of computer architecture in addition to a lot of system APIs exposed through the *nix kernel. ",
            "\u00a0I really sharpened my C programming skills and feel much more confident in my ability. I also learned about computer systems and the inner workings of a computer. ",
            "\u00a0I learned how to debug. ",
            "\u00a0An incredible course if you are interested in the theory side of CS. The computer architecture part may be obtuse but it is incredibly fascinating. ",
            "\u00a0Rigorous practice developing complex programs. Low-level computer organization including compression/decompression, error detection/correction, simple computer architecture (CPU, CU, AU, caches, etc.). The programming assignments are challenging, the specifications are incredibly detailed, and the test cases comprehensively test your program (in contrast to pretty much every CS course at Yale). This is by far the most worthwhile course in the major. They should all be like this. ",
            "\u00a0I learned about basic level computer system programming in this course, as well as C syntax and capabilities. ",
            "\u00a0Learned how to manage time. ",
            "\u00a0I learned how to debug and edge case. ",
            "\u00a0I learned a lot about how computers work and how to budget my time working on projects for classes ",
            "\u00a0Learned more about the inner workings of computers and developing algorithms ",
            "\u00a0Introduction to computer architecture, substantial experience writing and debugging C code. ",
            "\u00a0Basic knowledge of System programming and computer organizations. ",
            "\u00a0Ever wondered how things happen when you type something in on the command line? Hope so, since you'll be writing bash. From scratch. Ever wondered exactly what Richard Hendricks is doing on Silicon Valley? You better, since you'll be writing a compression algorithm. Also from scratch. 323 lets you peek behind the curtain of the computer functions that you use every day as a CS major, and even though I think Moses put in less work to part the Red Sea, somehow it's all worth it in the end. The course is legendary for a reason. ",
            "\u00a0complete course on systems programming. i learned how the linux shell works, how programms are written on it, error correcting codes, parallelism, and so much more. it was like an extension of 201 where we code in a useful language. ",
            "\u00a0I learned a decent amount about the ways in which computers work on a very basic level. ",
            "\u00a0I learned about Systems Programming. ",
            "\u00a0Learned how to program complex projects in C. Learned about bash, compression methods, computer architecture, and concurrency. ",
            "\u00a0I learned so much about the inner workings of a computer at the bits level. I can now open a terminal window and understand how many of the commands work. ",
            "\u00a0You gain confidence in programming and a proficiency in low-level concepts. You become a whiz in C programming and youearn how to think about edgecasing. ",
            "\u00a0So many skills!!!! Technically you learn about architecture, systems, etc, but the best part of this class is that I just don't feel afraid of any computer science now-- I know I am now equipped to get through it. ",
            "\u00a0I learned more about the physical architecture and systems of the computer. However, I think I grew most as a programmer and what I was able to learn when taking on larger projects (planning, implementing, debugging, testing, etc.) Whereas before, most projects I took on could easily be finished within a day, the problem sets I took on in this class forced me to be vigilant when coding and to not rush into uncharted territory. ",
            "\u00a0Learned a lot. Highly rate. Take it but you will die due to the amount of work. You can do it though. ",
            "\u00a0Computer architecture and low-level programming ",
            "\u00a0Practical programming experience and knowledge of various elements of computer system design ",
            "\u00a0Biggest takeaway is becoming a better programmer, and by that I mean writing boring code that gets the job done. I will say the course really does improve this skill, which I believe is valuable moving forwards. ",
            "\u00a0How to build a Bash shell and use GDB ",
            "\u00a0I learned a lot about computer architecture and shells, which was new from anything I'd learned before. The lectures were very different from the psets. The psets were extremely difficult and long, which required extreme time management. ",
            "\u00a0This course teaches you how to approach complex problems that at first seem entirely unintelligible. The class is probably the best in the entire cs department. ",
            "\u00a0Covered computer architecture and systems programming. More than anything how to skate by on 3 hours of sleep a week. ",
            "\u00a0Systems programming in C and basic computer architecture ",
            "\u00a0I definitely became a better programmer and got to experience what coding truly is at a higher level. Also understood a lot more about the inner workings of a computer. ",
            "\u00a0I truly learned how powerful I am as a human being by completing this class. This class will drag you through the mud, the dirt, through hellfire and back, but every time I would keep going and would learn what I'm truly capable of. I can now say that I can code somewhat in C, but MORE importantly, I made it through the 323 gauntlet ",
            "\u00a0Low level programming, how computers work, c coding ",
            "\u00a0Learned more about how computers work and communicate, error checking, a little more about C ",
            "\u00a0How to code more efficiently and manage time better. Systems level architecture ",
            "\u00a0I got better at programming (in C and in general) and understanding how computers work on a lower level. ",
            "\u00a0The main thing you learn is how to write good code that is clear to other readers, easy to debug, and clear enough that it can be divided into smaller parts. \r\nYou'll also learn some really interesting features of how operating systems work, compression, data error detection etc. \r\nIt's a tough class, but incredible valuable! ",
            "\u00a0I learned how to not be intimidated by a 6 page explanation of a program I have to code from (nearly) scratch. I learned how to pay attention to the small details from the assignment spec that would become incredibly helpful tips for shaping the whole structure of the code. I learned more about computer architecture and signals, which built nicely on top of what I learned in EE 202 and EE 201. ",
            "\u00a0Basic Systems and Computer Organization. ",
            "\u00a0This course teaches gives a nice overview of the fundamentals of computer architecture. Save for the final problem set, where you make your own shell, this doesn't include implementation details, but the concepts are still important. The problem sets are also notoriously long and difficult, so in that sense the course makes you a better C programmer (but only at the \"practice makes perfect\" level). ",
            "\u00a0I learned about computer architecture and gained a better understanding of how computers / low level systems work. ",
            "\u00a0Systems stuff on Unix machines more than anything else. ",
            "\u00a0understanding of operating system stuff, number representation, and error checking. ",
            "\u00a0I learned different binary number systems, aspects of files and directories in Unix, the Bash shell, concurrency and pipelining in programs, the different parts of a computer and how they interact, data compression, and other parts of computer organization and programming. I also further developed my coding and debugging skill in C from 223, since most of our programming assignments were in C. In addition to C, I also learned some Python for our third assignment. ",
            "\u00a0I learned a great deal about effective ways to program in this course. While the systems content itself was not particularly interesting, the skills gained by working on the problem sets are invaluable. I finally feel like a real programmer. ",
            "\u00a0Really enjoyed learning about concurrency, data compression, and the like. Didn't really become a better programmer by taking the course, and much of the time spent toward the course feels unsatisfying (working around specific edge cases to pass test scripts), which don't even necessarily contribute to more robust code. The course also didn't teach us anything about writing readable code or structuring our code. ",
            "\u00a0I became a much better programmer overall after completing this course. ",
            "\u00a0I gained the ability to write non-trivial computer programs, became more familiar with the C std libraries, learnt about some common compression/error-correction algorithms and a gained a general overview of the inner workings of computers. ",
            "\u00a0I became a much, much better programmer. I also learned a whole lot about how computers function on the hardware level, as well as a somewhat high level overview of how instructions are executed, how RAID works, and how different compression & error correction/detection algorithms function. ",
            "\u00a0Through the programming assignments, I learned how to organize the creation of a large program, debug efficiently even in difficult situations, and test thoroughly while dealing with ambiguities in specifications. These lessons felt very relevant, more so than previous CS courses, to the challenges of real-world software engineering. The systems content of the course, which was focused mainly in the lectures and the last assignment, taught me pieces of how Unix works from the hardware level to the standard library, and some of the design decisions that have gone into modern computers. While I'm not sure if I will use much of what I learned about systems, I still found it fascinating as an EECS major with an interest in what goes on \"under the hood.\" ",
            "\u00a0I learned a lot about how computers operate and systems in general. Topics included compression, error detection, basic computer architecture, virtual memory, instruction addressing and more. ",
            "\u00a0I gained more familiarity and experience with the C programming language, and learned more about the basic internal structures of operating systems and CPUs. ",
            "\u00a0Improved C programming skills, learned about workings of computers at a lower level. ",
            "\u00a0I got a lot better at C by doing the problem sets in this course. In lecture we covered topics including file systems, number representation, concurrency, computer organization, memory hierarchy, system calls for a bash shell, etc. I don't feel like I know everything about computers but I do feel like I'm more prepared to learn about the intricacies of other computer science topics after this course, because I'd never learned about all this nitty-gritty stuff before. ",
            "\u00a0An understanding of systems and how to program various features of a bash shell ",
            "\u00a0This was one of the most educational classes in the CS curriculum, and I learned lots about low-level systems and my C coding skills developed significantly. ",
            "\u00a0Linux, computer architecture, concurrency, detecting and correcting errors in compression/depression ",
            "\u00a0I learned about computer architectures, how to design modular code (if you don't figure out how to do that the psets get out of hand really quickly), how to start small and then scale up my programs, and how to use assorted tools like regex. ",
            "\u00a0Really honed my C skills and learned theory behind computer architecture, operating systems. ",
            "\u00a0Understanding of systems and larger coding projects in C. ",
            "\u00a0Systems, some OS, programming large projects in C, how to be a better programmer and write nicer code ",
            "\u00a0The course covers computer architecture, memory, encoding/decoding, parallel computing and other aspects of systems programming. "
        ],
        [
            "\u00a0Strengths: 1) you learn a lot, 2) completing each assignment is very satisfying.\r\n\r\nWeaknesses: 1) 30-40 hour PSETs on average, 2) few TAs so you have to be self-sufficient, 3) that one time you go to office hours, some students who are not self-sufficient will be hogging the TAs and wasting everyone's time. A system needs to be in place so that people seeking help in office hours are separated on the scale of: clueless - questions about the spec - conceptual - debugging. And time needs to be portioned for them appropriately. ",
            "\u00a0The lectures are usually pretty fast paced and it can be hard to understand everything until you go back and look through everything before the exams. The exams themselves count for very little, making them not overly stressful. On the other hand the psets count for 70% of the grade, so it is really important to manage your time well and plan in advance. I feel like poor planning is one of the reasons that this course has such an intense reputation. The assignments took an average of around 30 hours for most people, which spread out over ~2.5 weeks is not that hard to get done. The issue that many of my friends and I did not start them until the last week before the due date, forcing you to do ~5 hours of coding a day to pass all of the test cases. Furthermore, the private test cases are often extreme edge cases that sometimes seem really nit-picky, so you need to spend a good portion of the time just edge casing.\r\nMost of the psets are only slightly related to the course, and a good amount of the time is spent on relatively uninteresting code, like string processing. They are complex enough though that you will truly improve as a coder, albeit likely due to how much time you spend debugging your code.\r\nIn regard to grades, you never really know your grade, only how well you did relative to others for each assignment. ",
            "\u00a0Strengths: It definitely forces you to be very methodical about your approach to solving CS problems, as opposed to the simpler, and smaller-scale problems in CPSC223. Clean code becomes VERY important with the scale of these psets.\r\n\r\n'Weaknesses' (?): The class material and the pset material seems to be pretty disjoint, and the learning of how to code cleanly is pretty much self-taught (sometimes through pain) rather than explained in class. ",
            "\u00a0Strengths- great teacher, engaging course assignments\r\n\r\nWeaknesses- lack of sections, available help ",
            "\u00a0Stan is a genius ",
            "\u00a0I find the lectures to be rushed and not conducive to discussions surrounding the concepts being covered. There is very little encouragement to ask questions and when one does ask a question it is not by any means guaranteed that one won't receive a condescending answer from the professor ( what do you expect from someone who has been teaching the material for ~30 years and internalized it to an equal extent?) It is also extremely unhelpful that the CS department has adopted the ULA program as a sound pedagogical method. Imagine for instance if all departments across the entire college dispensed with their grad students and all undergrads hence forth would exclusively receive help from other undergrads who took the given course a year or two previous. How would this bode for the college as a whole and for the individual? Take CS323 to get an idea of just how bad it can be, which is to say that that CS323 is difficult for all of the wrong reasons. ",
            "\u00a0The problem sets, the Professor (Stan), as well as the TA's were all strengths. I learned the most from spending time thinking about problem sets and listening to Stan speak. The TA's also provided invaluable help when it came to starting and debugging problem sets. On the other hand, the class is very divided, there are students who readily pick up on the material and complete problem sets quickly and others who need a little more guidance. I think for the class to be more successful there needs to be a smaller divide, but this is hard to accomplish. Very few weaknesses, you can make this course as hard as you want, the basics of the course are simple and enjoyable, but if you want to edgecase until the wee hours of the night then that's up to you, oftentimes the best solution is the simplest and that was not what I felt about some of these problem sets and the edgecases I found. ",
            "\u00a0Strengths: It is well organized and rigorous.\r\n\r\nWeaknesses: The material feels quite specific at times, and not necessary for what most CS majors will be doing with their lives. ",
            "\u00a0This course teaches an incredible amount about computer science. Though the class itself was very difficult, I definitely came out the other side with tons of new programming knowledge. Stan is very well-informed about the topics and teaches in a very precise manner. In terms of weaknesses, the course lectures and problem sets are practically mutually exclusive. The systems programming part of the course was learned through problem sets and the computer organization part of the course through the classes and exams. It would have been great for the concepts to intertwine more. However, I understand why they don't and think that the class hedges mostly on problem sets, rather than class lectures or exams. ",
            "\u00a0Strengths - Very interesting course material and psets\r\nWeaknesses - Psets are almost entirely unrelated to lecture content ",
            "\u00a0I wish we spent more time in class discussing the problem sets and how to approach them. I also wish we covered lecture content in a slower pace. ",
            "\u00a0Strengths: you learn a lot, you come out of the course more confident in your programming, Stan is a great teacher and if you take the time to seek out his help he is more than willing to give it, everyone struggles together, the class is curved pretty fairly\r\n\r\nWeaknesses: extremely hard, huge workload if coding doesn't come naturally to you, you'll probably cry at least once, 40+ hours on homework not including readings and reviewing notes, exams were still rough ",
            "\u00a0As with any CS class, there are never enough TAs or office hours to help students during busy times of the week, but the TAs were always helpful and Stan always answers emails prompty! ",
            "\u00a0Strengths:\r\nI like that the course puts a lot of emphasis on personal assignments. I also like that it makes sure the students submit a work log to minimize discussion between peers.\r\n\r\nWeaknesses:\r\nI really really wish we had a bigger classroom. The class is always nearly full and as a result, people were forced to sit on the floor or all the way in the back. The professor always insists that there are still some seats open, but some seats are just broken (have no desks) or it's just hard to see the entire board from those seats. If the class had just been moved to a different classroom, students would certainly have more incentive to come to class and have a good class experience. ",
            "\u00a0The inconsistency in this course is how it's lecturing mainly discuss the *nix system architecture while the programming assignments are not therein focused. Still, the course covers a fair amount of system architecture in a comprehensive manner, which I appreciated. ",
            "\u00a0I think I really am a better programmer and I learned a lot. I wish sometimes what we learned in class lined up more with out homework assignments. Most assignments do, but some seem random, like \"clipp\" for example. ",
            "\u00a0It's fine. ",
            "\u00a0Programming assignments were great. Stan is a clear lecturer and a fair grader. It should not change. ",
            "\u00a0This course is notoriously work-heavy, and psets were often upwards 30 hours of my time. I think this course teaches you to be a good programmer, encouraging you to edge case and approach it top-down, but constantly working on psets for the entire semester was pretty mentally exhausting. ",
            "\u00a0Nothing to complain. I just would really like for the class notes to perhaps to be posted online, given that it can be difficult to understand what is going on during  class and the material does not follow exactly what is in the textbooks. ",
            "\u00a0The psets take so long to finish! However you learn a lot and grow really close with your peers. ",
            "\u00a0The weaknesses of this course were that the classroom content did not apply to the projects very often. Only on two of the problem sets was the classroom content applicable to the actual project. ",
            "\u00a0+ My programming skills improved substantially throughout this course due to working on the psets. \r\n- In class exams eat up valuable class time that could instead be used for lecture. ",
            "\u00a0Doable workload. The assignment and the lecture do not go along with each other though. ",
            "\u00a0Strengths: Eisenstat's handwriting, pretty solid teaching for a CS class\r\nWeaknesses: disconnect between lecture and psets, the test cases largely test edge cases, and it's infuriating ",
            "\u00a0strength: good lectures, well designed psets, quality community\r\nweaknesses: no lecture notes, would have helped a lot. ",
            "\u00a0Office hours are incredibly helpful. ",
            "\u00a0I think this course is a ton of work just for the sake of being a ton of work.  The actual things you program don't feel incredibly useful or applicable.  As the final programming class required by the computer science major, I think it's a bit lackluster.  The problem sets are terribly long,  the exams have little to no overlap to what you program outside the classroom, and most programming learned is useless after graduation. ",
            "\u00a0Strengths: excellent material and outstanding professor/lectures. \r\nWeaknesses: getting easier as years go on. ",
            "\u00a0I think this course was well structured and office hours were really helpful. They facilitated as much help as they possibly could. ",
            "\u00a0This class could be 2 credits. The assignments take an enormous amount of time and are very consuming. Also, for the first three assignments, a lot of what Professor Eisenstat taught in class was not related to what we had to code up, so it's as if we were taking two different courses: one for lecture/midterms, and one for the problem sets. I'd suggest integrating the two more, it seemed like a systems class and a complex c coding class meshed in one. ",
            "\u00a0Prof. Eisenstat is an amazing lecturer. He discusses concepts so thoroughly in class that as long as you study your notes meticulously, you learn so much and will also do well in the tests. The assignments are very cool and although they are hard, you feel very accomplished at the end. ",
            "\u00a0Strength: Prof E is an amazing professor. He is a great teacher and his lectures are organized, albeit fast.\r\n\r\nWeakness: psets are very rough and if you fall behind it is very hard to recover. Prof E is also very blunt. ",
            "\u00a0Strengths: Professor Eisenstat was a good lecturer. Sometimes he went too fast / made assumptions about what we knew, but for the most part he was very clear, which is amazing considering how difficult the material is. \r\n\r\nWeaknesses: this class just takes over your life. I do understand that the material is hard, but I wonder if it is absolutely necessary for the class to be as painful as it is? Perhaps it could be split up over two semesters? ",
            "\u00a0I thought this class really forced me to grow as a programmer. However, I thought that the PSets could better reflect the material we were learning in class. There were only two problem sets that were relevant to what we were learning in class, and the majority of the work we were doing involved string parsing for the first few problem sets. I felt that there could have been better balance between the problem sets we did for homework and the material we were learning in class. ",
            "\u00a0The course covers material well, but often the material doesn't feel super interesting or relevant. Compression algorithms were probably the most interesting aspect of the course. However, the topics covered in the second half of the course felt relatively disconnected from each other. I wish there had been a few more lectures connecting all of the material we covered, and that some more time had been reserved for Networks. ",
            "\u00a0the lack of lecture notes really did it to me. Yeah sure there are readings on the topics but the computer architecture textbook really isn't helpful for a student like me with 5 brain cells remaining by the end of the semester ",
            "\u00a0Requires a ton of time to do well, or at least a ton of diligence and good time management. Stan is a great lecturer and really helps you out, so go to his office hours. The TAs are amazing as well. Weakness is you do not get feedback on your programming assignments other than the grade unless you seek out Stan, so if you have bad coding habits that screw you from the start, you will not know and just continue to screw yourself. ",
            "\u00a0The psets are tedious, but its kinda necessary for this kind of course ",
            "\u00a0Generally strong course. Assignments could be more related to class work, but the current system is not bad, as the assignments are very interesting. ",
            "\u00a0Homework and lectures were not related for most part, which is kind of annoying. ",
            "\u00a0The lecture has almost nothing to do with the psets. This course is like taking two classes at once. ",
            "\u00a0Way too hard. Needs to be completely overhauled to facilitate student learning. ",
            "\u00a0There isnt a lot of instruction about how to approach problems at first. This was my second attempt at taking this course. ",
            "\u00a0Strengths, the professor is very knowledgeable and gives great lectures. \r\nWeaknesses, no support for the assignments and no mercy. ",
            "\u00a0Strengths: Professor Eisenstat really cares about this course and his students. He's readily accessible for help and responds incredibly quickly to emails.\r\nWeaknesses: The course structure is poorly planned. The homework and classwork barely have any intersections, and the readings are just plain optional. ",
            "\u00a0THIS CLASS IS BASICALLY TWO CLASSES nothing you learn in class (aside from LZW compression algorithm) is going to help you on the psets and vice versa, so you MUST go to lecture and you MUST go to office hours/spend hours and hours coding the psets. Eisenstat is AWESOME and so willing to help but the class itself is literally so much work i cri ",
            "\u00a0Strengths: you can tell if you want to go further with cs and you learn a lot.\r\nWeakness: it is too much work, it's insane. And it's not so intellectually challenging, just really a very heavy workload. Class doesn't help much with the homework, and homework doesn't help much with exams. It made me hate cs. ",
            "\u00a0Weaknesses are that the class consumes your life and leaves you with no free time and makes you sacrifice your other classes. No strengths that come to mind, the class is just unreasonably difficult and time consuming to the point where it is ridiculous. ",
            "\u00a0More teaching staff ",
            "\u00a0Lectures basically 100% unrelated to problem sets, felt a bit disjoint. It kind of works, but I think the course could be improved by potentially splitting it into two sections; one that's based on the lectures/exams, and another that's based on the problem sets. A lot of material is covered and the lectures progress in a clear way. ",
            "\u00a0Strengths- engaging problem sets (very hard, but interesting and fun to build!), interesting lecture material and great textbook, class really build camaraderie as you go along! \r\nWeaknesses - not as much a weakness as a fact of 323, but the edge cases and problem set deadlines can be very stressful and demanding. ",
            "\u00a0Very difficult p-sets but lecture topics were much more straight forward. Unfortunately lecture and psets were not very correlated. ",
            "\u00a0The course made me feel like I understood the concepts by the end, though this was because of lecture and not because of the problem sets. A major weakness was that the problem sets and the lecture were largely unrelated until the final assignment. A major strength was that there is a generous late policy. ",
            "\u00a0The biggest strength of this course was that while the problem sets were difficult and time consuming, I felt like I became a much better programmer because of them. In addition, the lectures covered a wide range of topics. I also really appreciated the various problem set walkthroughs / all the support from the teaching staff. The biggest weakness of the course was that, for the most part, the lectures and the problem sets felt very disconnected, making the already difficult problem sets more challenging; I wish all of the problem sets could reinforce what we were learning in class and be assigned roughly at the same time as we were covering the topic in class. In addition, for some of the problem sets, because there weren't enough TAs / ULAs, it took a very long time ( > 2 hours in some cases) to get helped, which could be extremely frustrating. ",
            "\u00a0Problems sets force you to learn a ton. The material we learned in class was pretty separate from what we implemented in our assignments though. ",
            "\u00a0course seemed good. not a lot of courses to relate it to. ",
            "\u00a0The lectures were generally clear-cut, and the goals of the programming assignments were clear on the specifications. I feel as if the first programming assignment might have been a jump in difficulty so early in the semester, and put a lot of pressure on the class in the first few weeks of class. Office hours were a great place to get one-on-one help with difficult programming problems, and the number of ULAs was usually enough so that if you started the assignment early, you could get helped. ",
            "\u00a0I thought that this course could have been improved my more TA's and more guidelines for edge casing. Especially the first assignment was really difficult because it was not particularly clear how to edge case and so grades were not as good as other assignments where edge casing was not as important. I thought in general the first assignment was the most difficult of the semester. ",
            "\u00a0Taught certain concepts well, though lectures could be sped up 5x if they were printed on slides rather than written on a chalkboard. Material was far more understandable upon review than lecture (this could definitely be improved). Also, majority of time in problem sets was wasted on thinking about specific test cases (useful, but time could be better spent elsewhere in my opinion) ",
            "\u00a0I think that overall the course is great. My only complaint would be that sometimes lectures were a little dry. ",
            "\u00a0The greatest strength of the course is probably in its assignments. You learn to build robust programs that meet some particular specifications. Exams are well designed and hit the 'sweet-spot' too. Lectures are decently engaging, but could be improved by explaining the overall idea of a topic/concept before delving into the nitty-gritty details of the topic itself. I occasionally found myself slightly lost in lectures and had to piece together bits of information as the lecture progressed to form a better picture of the topic (I doubt I'm the only one, since I did decently well in the course). ",
            "\u00a0This is quite a difficult class. It really hits hard with the psets (most of which will take >20 hrs to complete), however they are spread out over 2+ weeks, so as long as you don't leave it all to the last minute you'll be fine. ",
            "\u00a0The instructor should aim to better connect the lecture material with the assignment material.\r\n\r\nI worry that a student could go through the core CS sequence writing garbage code. No one will ask questions if you submit 1,000 lines for an assignment that Stan solved in 180. Often the shortest student solutions are a good 20% longer than Stans. He should host a code review session after every assignment where he walks through his code. ",
            "\u00a0The level of thought that Prof. Eisenstat has put into the lectures and assignments makes sure that the long hours everyone spends on this course are actually productive learning. The systems content in the lectures is well organized and clearly explained, though lecture notes or textbook material that covered the same content instead of adding many new ideas would be helpful. Each assignment required a slightly different set of skills, providing a useful range of practice. The emphasis on testing, though it can easily become frustrating when it adds several hours to each assignment, teaches important skills that aren't emphasized in other core CS classes. The main weakness of this course is that most of the assignments are barely connected to the lecture material, so there is basically no way to practice the lecture material before the exams except for pure memorization. Non-programming assignments to cover this material would be very helpful, but would probably be infeasible with the existing programming workload. ",
            "\u00a0The strengths are that if you pay attention in lecture and take notes you will have a solid theoretical understanding of basic systems programming. One weakness is that the problem sets do take a long time and could probably be each be split into two shorter assignments and have one due each week instead of one due every two weeks. ",
            "\u00a0The problem sets in this class were challenging but rewarding, and I learned a lot in the process of implementing them. The lectures were useful, but were usually completely independent of what was asked in the assignments. If assignments aligned more with the subjects being taught in class, this might help in learning the material covered in class. ",
            "\u00a0The strengths are that it covers a good selection of material, with virtually everything learned being quite useful. The weaknesses are that the psets are very disjointed from the contents of the lectures: the lectures operate a couple of weeks ahead of the psets, and thus things covered in a lecture will not appear on a pset for as much as a month. ",
            "\u00a0I think the problem sets are almost needlessly difficult, because the lengthy specification can be so intimidating and confusing and just long that it takes literal days to understand and begin coding. The ULA sessions going over the later specs were really helpful in getting past that barrier, though-- I think those should become a staple for all assignments. I think more should be done to make the problem sets less scary, because they are built up in our minds by reviews and whispers from our peers and that makes them so much less approachable-- when in fact the actual coding problem is sometimes more manageable than others would have you believe. And the class is supposed to push students to tackle larger and more complex coding projects than they have before, but right now a big part of it is also testing how you code under fear. On a related note, I think the anti-collaboration policy may go a bit too far-- I appreciate the idea of making students practice independent problem-solving, but the result is that when you get stuck, your only resource is the ULAs, which means waiting in a queue for hours. By the end of the course I barely knew three other people in the whole class. Another improvement I would suggest is to tie the in-class material in closer with the problem sets-- at times they fit together but most of the time it was like I was in two separate classes. ",
            "\u00a0Our final and our last assignment were due within a few days of each other, which induced unnecessary stress. I would have liked for our final to be after reading period instead. ",
            "\u00a0This is a phenomenal course. Professor Eisenstat is a legend for a reason--he is an incredibly amazing professor and knows/teaches the material really well. With that said, this course was also really difficult. You're probably taking this course because it is required for the major, so just stick with it, work hard, and you'll come out on the other side. ",
            "\u00a0Weaknesses: There is way to much packed into this course. It's essentially like taking two courses in one. The stuff you learn in class rarely correlates to the stuff that's on the psets. If this course is going to be required and it's going to take up someone's entire semester it should either be 1.5 or 2 credits like a foreign language or it should be split into two classes\r\n\r\nStrengths: Professor Eisenstat is the best. His lectures are organized and comprehensive. There are office hours five nights a week and Professor Eisenstat is more than happy to meet with you or correspond via email if you are having trouble. In short, given how difficult the class is, there is a lot of support. ",
            "\u00a0Maybe more interplay between lectures and problem sets? Could be interesting to see how theoretical concepts like Hamming distances are applied in pracctice. ",
            "\u00a0This course is far too large to be taught effectively. Too often, students are left behind while some who are better at coding succeed. Any positive feedback with respect to the course is the result of the course's status as a juggernaut that must be \"survived.\" In general, throughout one's Yale experience, he or she will know great challenge. This class is not such a challengeit devastates students for no apparent pedagogical reason. ",
            "\u00a0Strengths: material is fascinating, well-explained, and I became a much better programmer\r\nWeaknesses: very overwhelming, exams don't test knowledge super well (all rides on 4 questions) and are very hard to complete in the allotted time, the first pset felt less relevant and far too difficult (afterwards psets were more manageable) ",
            "\u00a0Eisenstat is one of the best CS lecturers and is also helpful in office hours or with emails. Definitely a hard course, but you'll learn a lot and feel very accomplished. "
        ],
        [
            "\u00a0We all know this is a hard course. If you're a CS major you have to take it. You've also probably heard all the advice: 1) start PSETs early, 2) ask the TAs and Professor Eisenstat (who is great with replies) for help, 3) try doing the book readings for a conceptual background, 4) show up to class for the exams. Even if you do all of that, it's still going to be difficult.\r\n\r\nThis year (2018) wasn't that bad. Prof. E made the first PSET pretty difficult, and a lot of people dropped. So the silver lining was that subsequent PSETs were easier and the last one was cancelled. ",
            "\u00a0Oh god no. ",
            "\u00a0If you're a cs major, u have to take it. Otherwise, I dont really know why you would take this course. You will learn a good amount, but arguably too much workload to take if not for your major. I would recommend at least a decent understanding cs223 first, and review the course if you are not up to speed on data structures and C in general. While the psets are not focused on data structures per se, you often need to implement them to solve some other problem, in which it would be ideal to know what to implement and how without much difficulty. Also, learn some debugging strategies, as the code deals with large enough inputs that manually debugging is sometime not a reasonable option. ",
            "\u00a0I mean you have to if you are a CS major, and you shouldn't if you are not. Why torture yourself? ",
            "\u00a0Recommended for CS majors, probably not necessary to take this course for other majors. ",
            "\u00a0Yes for stan! ",
            "\u00a0No. The CS department is not equipped to aid so many students with a course that has a workload of this magnitude and type. Maybe back in the day when there were a handful of CS majors such a course could be given comfortably with most everyone getting the help they needed when they needed it. This is no longer the case. ",
            "\u00a0Sure! If data structures was cool to you, this will make you think differently about computer science, but is invaluable in any kind of role that requires some level of computer interaction. In addition, this course will open up your mind to so many aspects of computer science, so it is definitely worth exploring! ",
            "\u00a0Only if they are a CS major or are specifically interested in the topic; I feel like the main benefits of this course, in terms of improving my programming skills, would be better gained doing more contemporary and interesting assignments. ",
            "\u00a0Do not take this course unless you have to for your major. Though I'm happy about all the knowledge I gained from taking this course, I'm not sure the experience was worth the knowledge I left with. As someone with an anxiety disorder, this course practically destroyed my well-being. I was constantly stressed about finishing problem sets and understanding material. Especially during LZW, I became incredibly focused on finishing the problem set and basically had to drop everything else in my life to finish the assignment. There needs to be a conversation started about people with mental health conditions who take this course. As soon as the class ended, I actually considered dropping the CS major because of the stress and anxiety that I now associate with computer science. I know multiple people who dropped this course for mental health reasons. A Yale course should not do this. Please think about how this course can be more manageable for people who deal with mental health problems. Computer science should be a more inclusive space and a course that's so hard on people with mental health conditions will just push people with a unique perspective out of the field. I know that CS323 has been a staple of the computer science degree for years, but this is simply something that must be discussed for computer science to become better at Yale. ",
            "\u00a0If you're interested in the course material, then definitely. This class is infamous for a high workload, but it was entirely manageable if you start early and work continuously to the deadline. Make sure you'll have time to spend an hour or two on this class everyday because if not you might be pressed for time when trying to complete the assignments. I found the psets to be challenging, interesting, and rewarding. It was a really interesting and fun class and I'd recommend it to anyone who is on top of their work. If not, it'll be a tough time and possibly some late nights, but worth it in my opinion. ",
            "\u00a0Deffinitely, the problem sets are super cool and the lecture content is also very cool. The problem sets helped me become a more confident programmer and learn so much more about C. I feel a lot more comfortable with C and writing a lot of code. ",
            "\u00a0If you are in the major, you have to take it, and honestly you will come out a better programmer. However, be warned, this course is VERY hard and the workload is like taking two courses. If you aren't in the major, probably don't take it, but if you are you will at least learn a lot. ",
            "\u00a0If you want to become much better at programming and understanding computers, take the class. Be prepared for the infamous workload, however. ",
            "\u00a0You are probably only taking this course if you are CS or EECS, so yea try and get it out of the way as quickly as possible to get to the more fun classes in the major. If you do end up taking this as a non-major, make sure you are taking it as the \"difficult class\" of your semester as it will definitely try to suck up all of your time. I didn't end up doing time management as well as I should've for most assignments, and almost every one resulted in my pulling 3-4 all nighters in a row to get the assignments in on time. ",
            "\u00a0No, unless they need to take it. It is really difficult, time-consuming, and would not be an enjoyable experience unless you're really really into programming and understanding how the computer works. ",
            "\u00a0I would recommend this class, but simply for its content, not its workload. ",
            "\u00a0Yes. You will have a greater knowledge of CS and better problem solving abilities. It is a lot of work. ",
            "\u00a0If it's required for your major, you know what you're getting yourself into. If not, absolutely not unless you're trying to make sure you don't get enough sleep for an entire semester. ",
            "\u00a0I would recommend this course to another student who likes logical thinking -- I mean actually pure logic involved in doing the psets right, as in, bug free. ",
            "\u00a0Lets face it: if you are considering 323, you probably need this for a major req. Yes, it is as hard as people say it is. Yes, you can survive it. At least you walk away from the class with a lot of new found appreciation for CS. ",
            "\u00a0Yes. It is the most important course for learning to comprehensively test your code. ",
            "\u00a0Only if you need to take it for the major... or really want to know this stuff. ",
            "\u00a0You have to take it for CS, so only for that ",
            "\u00a0NOOO RUN AWAY ",
            "\u00a0If you are a CS major, you have to take it. Otherwise, I would not because it is a very demanding course that is not an introduction in any way. ",
            "\u00a0If you have to take it ",
            "\u00a0Good course for gaining more programming experience, exposure to topics in computer architecture. ",
            "\u00a0Highly recommend to CS major students. Well-taught and the professor is very patient. ",
            "\u00a0Does it even matter? You have to take it.\r\n\r\n(If you don't, I'd recommend it if you really want to know how computers work and have time to *burn*.) ",
            "\u00a0Yes ",
            "\u00a0yes, it hurt but i feel like a much more effective and qualified programmer. like, in 201 and 223 looking back i only made pretty simple programs, in this class you'll get to code the linux shell (that can parse and run any program in the command line) and work on a pset spec with like 100 different features, and it's edifying and gratifying to finally be like woah i actually made this. Stan, for all his old-school tendencies, really does work very hard to design the class to be challenging and frustrating but also doable, and his accessibility and openness (he'll literally look through your code for bugs if you ask him to) shows that he's on your side. There are classes that are hard and frustrating because they're poorly designed, and then there's this class, which is the opposite. You'll come out of really feeling like you gained something. ",
            "\u00a0For CS majors only. ",
            "\u00a0Don't put yourself through this unless you have to. ",
            "\u00a0This course is a rite of passage. Take it. ",
            "\u00a0Yes. C programming is essential to a morally sound life. ",
            "\u00a0Only for the major or if you would like to get really good at C or programming in general. ",
            "\u00a0Yes! Prof. Eisenstat is absolutely amazing, and the material in 323 is essential for any computer science student. Furthermore, the problem sets are so interesting and really teach you how to debug, test, and clean up your code. ",
            "\u00a0Yes. Its required by the major and is a right of passage for CS majors. However, if you don't want to major in CS just avoid it. ",
            "\u00a0Yes, because you really do get out of it what you put into it. But also be aware that it takes over your life. ",
            "\u00a0Yes if you are a computer science major. ",
            "\u00a0It's 323. If you're a CS major you have to take it. If not, I don't find the underlying topics very interesting - seems like more of an excuse to assign very time-consuming problem sets to make sure you have your coding skills up to snuff. Start P-Sets early and check your strategies with the TAs. ",
            "\u00a0chances are that you are only planning on taking this class because you have to. Just know that the assignments aren't too bad as long as you don't try to complete them in less than a week. And for the love of our Lord and Savior Jesus H. Christ, take 20 minutes out of your life to learn gdb... this skill alone cut the time to complete my assignments by half. ",
            "\u00a0Yes, because you have to. But also yes because computer architecture is really interesting and important for every CS person to know. ",
            "\u00a0Id recommend it only if you have to take it or if you really want to improve your programming skills ",
            "\u00a0Yes - it is an excellent introduction to C ",
            "\u00a0For someone willing to put in 10-15 hours a week, definitely. ",
            "\u00a0Only if youre in the CS major because it is a requirement. ",
            "\u00a0If you are a CS major, you must take it. Good luck... ",
            "\u00a0Well no, but it doesn't matter because you have to take it to major in CS. It's not that I didn't learn a lot or felt that the material wasn't extremely valuable, but it was the most painful semester of my life. This class killed a part of my soul, and the most I can say is that I survived it. I am just amazed that I made it through to the end. Good luck! ",
            "\u00a0If they're a CS major ",
            "\u00a0If you aren't a CS major, there's no need to take this course ",
            "\u00a0I would recommend it to people serious about CS. ",
            "\u00a0Don't take this class if you don't have to. SERIOUSLY. I had no life for an entire semester and it is entirely because of this class. If you have to take it, you will get through it i promise, but if you don't need to take this class then for the love of God just don't do it ",
            "\u00a0If you are in the cs major you have to take it. If you love cs enough to take this course and enjoy it, you should probably be in the cs major. Otherwise, this is going to make you suffer a lot so don't take it. ",
            "\u00a0If you want to be a CS major, it is required so I am sorry for you. Do not take this class unless it is required or unless you want to spend 20 hours a week on it ",
            "\u00a0Yes. For cs majors it's required and if not, then you can gain valuable coding skills ",
            "\u00a0If you want to get better at programming, this is a pretty good way to do it, but it might not be that valuable for that purpose since it's in C. It's a ton of work, so you really need to be taking it if you're interested in the lecture material and also the programming assignments. Some of them were honestly kind of fun if you like programming. Probably not worth taking if you don't need to for the computer science major though. ",
            "\u00a0If you're a CS major, you have to take it (haha)... The course is difficult and lives up to the challenge that many previous peers have described, but it can be a positive experience where you learn a lot and form close bonds with your peers as you learn and struggle together. This class really changed the way I approach problems! One tip - start early, there's no such thing as finishing a problem set early in this class :) \r\nIf you're not a CS major, think hard before taking it. The class is stressful and time consuming and even passing public tests (i.e. 20% of your grade) takes many hours - and your semester will be very code-focused. If you like coding this is great and you'll learn a lot, but I wouldn't say this is a class to just tack on for fun... ",
            "\u00a0Necessary for Computer Science Majors ",
            "\u00a0If you're a computer science major, this course is a requirement. It's a ton of work, the problem sets are long, intricate, and difficult, and the grading isn't particularly generous, but you do learn a lot. If you're not a computer science major, I will say that this is a good course. I can't possibly imagine that the rest of your semester is easy enough that you're looking to spend all your time on a nonessential course, but it will teach a good overview of systems programming. This course is notorious for a reason. ",
            "\u00a0I would recommend this course. Even though there's a big workload, you learn a lot from it. ",
            "\u00a0You've got to take it. Try to enjoy the assignments -- they're a lot of fun once you dig your teeth in. ",
            "\u00a0yes. but would warn student that they should already be a capable programmer. ",
            "\u00a0I would recommend this course to a student majoring in computer science, since it is a part of the core curriculum. CPSC 323 has a strong reputation, and I would be lying if I said I didn't spend a lot of time this semester engaged in this class. The lectures are pretty straightforward, and Prof. Eisenstat thoroughly knows the information since he was teaching the class before you were born. You learn how to debug code, acknowledging that passing public test cases never meant anything, and with each problem set, your programming skills grow (even if just a little bit). OH will be stressful at times, but bouncing ideas off of other students is helpful for the programming assignments. The ULAs, having gone through the course before, understand the struggle of the class and really try to help you with any problems. Professor Eisenstat is available for any questions you might have, and also made the programming assignments simpler when the class was struggling. He is also very nice about grading. If you devote a lot of effort to the class, you will usually end up on top, but sometimes that doesn't happen and its totally fine. 323 is the border class into the major, and once you tumble (or calmly walk) through the forest that is that class, you gain better programming skills and an in-depth knowledge of computer organization and systems. \r\nConcerning the content matter of the class itself, I understand that the computer science program at Yale is weaker than at other schools, but I wonder if this course (and other courses) need adjustments in the class material (there is a quora post about CS at Yale v MIT, which presents a strong critique of 323). ",
            "\u00a0Only majors and masochists will take this course. The psets will take over your semester, but the in-class material isn't overly difficult. For the in-class stuff, Professor Eisenstat will often forget how n00by students are and will start off getting down into the details of the topics without first giving a general overview of how whatever you're talking about fits into the big picture. For example, we would get right into the details of how virtual memory is implemented, and we were like \"but what is virtual memory and why do we want it.\" A three-minute youtube video later and were like \"ohhhh nowwww I get it\" - so if you find yourself confused about the big picture, I recommend watching a short video or two to contextualize what you learn in class. ",
            "\u00a0I would recommend this course to anyone who wants to be a computer programmer and desires to improve their skills in this area. It makes you think outside of the box on how to solve problems, and one of the best parts is that there is no right answer to the homework assignments. ",
            "\u00a0Take it if you need the programming experience. Definitely not the best use of your time otherwise though unless the course becomes more streamlined. The professor makes the first problem set difficult just to get most of the students to drop out--this seems a work-around for a larger issue. Rather than making complicated and voluminous problem early problem sets, they could be targeted toward a more specific functionality (specs are all over the place). Working on problem sets feels more like nitpicking the spec than actually becoming a better programmer. ",
            "\u00a0Yeah, I had some friends who aren't computer science majors in the class with me who enjoyed it as well. I think that if you want to learn how to program well and efficiently it's a great course to take. ",
            "\u00a0If you would like to find out if a career in CS a good fit for you, then take this course - if you end up spending 50+ hours on each assignment and find yourself on the verge of tears every Thursday night, then being a CS Major probably isn't a good idea.  The class will teach you some operating system concepts, a few error-correcting/compression algorithms, and (largely through trial-and-error) how to write solid programs.\r\n\r\nSome tips: Start on assignments early, make a very detailed outline of the program you intend to write BEFORE you start coding, use GDB, and don't go to office hours unless absolutely necessary. ",
            "\u00a0YES! I had a ton of fun taking this course and would recommend it to anyone fascinated by computer science or who wants to improve their coding ability. Yale CS alumni will give you a lot of respect for completing 323. ",
            "\u00a0If you know C, you can easily take 323. You need not take 223 first. Sure, youll need to know how to implement a linked list and hash table. But anyone can figure this out in not more than an hour. If youre confident with C, dont waste your time on 223.\r\n\r\nIntellectually, 323 is straight-forward but interesting. The lectures are clear and easy to follow. The concepts are mostly understood with a quick read on Wikipedia. The class is difficult only because its programming assignments are large and time-consuming. Even so, the workload has lightened in recent years. There were only 5 assignments this semester, compared with the usual 6. ",
            "\u00a0It's a great course, but you'd still be a bit crazy to take it unless you're a CS major or really, really interested in production-quality programming. The course, as many others have said, is more like two courses: not just in the time the average student spends on it, but also in the way that 3 or 4 of the 5 programming assignments are almost entirely unrelated to the lecture material. One course is like an extension of 223 that gives you hard, detail-focused programming assignments to make you a better programmer and teach you about thorough testing and edge-casing, while the other is *actually* an introduction to systems programming and computer architecture that only really gets put into practice with the last assignment.\r\n\r\nThis two-course structure means that the exams take a lot of studying and can be quite hard since you haven't been practicing the material all semester. Luckily, the grading is heavily weighted toward the problem sets and the overall curve is fairly generous. Prof. Eisenstat knows the material incredibly well, and though he can come across as impatient with questions during lecture, he'll give you extremely patient explanations during office hours.\r\n\r\nThis course requires a whole different level of debugging skill, attention to detail, and testing than any previous CS class, but at least for me it felt completely worthwhile. ",
            "\u00a0I would recommend this course to another student only if you have to take it for your major or are very good at programming. ",
            "\u00a0Required course if you're a CS major. Served as a good introductory overview of systems concepts, and is likely going to be quite useful in pretty much any CS elective you will end up taking. Problem sets are challenging but doable, and can be reasonably be completed in <20hrs of work (over 2-3 weeks), which means you can get away with spending no more than 10 hours a week on this class. If you don't plan or spend your time well, it can get more out of hand. ",
            "\u00a0Anybody who takes this class is here because they have to, not because they want to. As such, it seems silly to write about whether I would recommend the course. ",
            "\u00a0As someone who took the class when it was not required for my major, I would not recommend that others do the same. I do believe that it improved my coding skills in C, maybe even by a lot, because the problem sets required tackling larger and more complex problems than I had seen before, and more independently. I also found some of the in-class material interesting. However, CPSC 323 is dominated by a culture of stress and fear, so any enrichment I gained was overpowered by equal or greater damage to my mental state. If you do need to take the class, here are some things to expect: The in-class material is often divorced from the problem sets, but there are enough topics in-class that are *essential* for the problem sets that you do need to attend class regularly and take notes-- because there are no online class notes and the material doesn't match up well with any textbook. There were 5 problem sets this semester (usually 6) which varied in length-- the class average ranged between 18 and 35 hours if I recall correctly (as in, one assignment had an average of 35 hours and others had 25 or 20), though it is possible to spend much less or much more time on each assignment. 4 of the problem sets were in C (file archiver, command line parser, data compression, bash shell) and one was in your choice of Python 2/Python 3/Ruby (C preprocessor). The specifications for each problem set were very long and confusing and detailed-- I would recommend devoting several hours to reading them well in advance of when you plan to start coding, and attending ULA sessions going over the spec if they are offered. The spec can be intimidating but you need to trust that once you get started coding, it will be doable-- do not let yourself become afraid of these problem sets, as it will make them infinitely more difficult. Start early, and get help from ULAs early (if you're stuck for more than half an hour, get help!), and learn how to debug your own code. Also, do NOT underestimate the Python assignment(s)-- they will not be as easy or as quick as you might think. The two exams (in-class midterm and non-cumulative in-class final) were mostly manageable-- some of the questions felt a bit out of the blue at times but the partial credit was very very generous, and problem sets made up about 70% of the final grade anyway. Also, Stan is actually pretty nice one-on-one and he is willing to look at your code and tell you what is going wrong, so don't let the curt manner in-class scare you away from his office hours. ",
            "\u00a0only if you major in CS ",
            "\u00a0Yes, if you're a CS major you have to take this course and definitely recommend taking it with Stan. It'll be a lot of work but you will learn a lot. ",
            "\u00a0Yes. If you are in the CS program, this class is invaluable. ",
            "\u00a0Yes if you're taking it for the major. ",
            "\u00a0Only take this course if you need it for the major. It is an extremely difficult and time consuming course. That being said if you have to take it there is a lot of support in place for you to succeed. Just keep in mind that it will be a hard semester and structure your workload in other classes accordingly. ",
            "\u00a0Yes, if you are interested in computer science, this class makes you feel like a competent and well-informed programmer. ",
            "\u00a0You're taking this class because it's required. Modify your schedule to accommodate if it is still offered, and hope that the computer science department works to provide a more sustainable, more effective option in the future. ",
            "\u00a0If you're a CS major yes because you have to but also because you will improve a ton-- just make sure you start the work early ",
            "\u00a0This class is super hard but Stan is relatively understanding if you need help. Best of luck! ",
            "\u00a0Yes, you'll learn to be a better programmer and a lot of interesting content. ",
            "\u00a0Don't take it unless you have to. "
        ]
    ]
}